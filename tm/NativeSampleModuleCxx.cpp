// Note to react-native-turbo-lnd contributors:
// This file is automatically generated by the protoc plugin inside the
// protoc-generator folder.
// Any changes to this file should be made there instead.
#include "NativeSampleModuleCxx.h"

#include "liblnd.h"

#include "PromiseKeeper.h"
#include "CallbackKeeper.h"
#include "WritableStreamHostObject.h"
#include "base64.hpp"
#include "log.h"

namespace facebook::react {

NativeSampleModuleCxx::NativeSampleModuleCxx(std::shared_ptr<CallInvoker> jsInvoker)
    : NativeSampleModuleCxxCxxSpec(std::move(jsInvoker)) {}

void NativeSampleModuleCxx::promiseOnResponseStatic(void* context, const char* data, int length) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    std::string encoded = base64::to_base64(std::string_view(data, length));
    PromiseKeeper::getInstance().resolvePromise(id, std::move(encoded));
}

void NativeSampleModuleCxx::promiseOnErrorStatic(void* context, const char* error) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    PromiseKeeper::getInstance().rejectPromise(id, std::string(error));
}

void NativeSampleModuleCxx::callbackOnResponseStatic(void* context, const char* data, int length) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    std::string encoded = base64::to_base64(std::string_view(data, length));
    CallbackKeeper::getInstance().invokeResponseCallback(id, std::move(encoded));
}

void NativeSampleModuleCxx::callbackOnErrorStatic(void* context, const char* error) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    CallbackKeeper::getInstance().invokeErrorCallback(id, std::string(error));
}

facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::start(jsi::Runtime &rt, jsi::String args) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = [](void* context, const char* data, int length) {
            uint64_t id = reinterpret_cast<uint64_t>(context);
            std::string encoded = base64::to_base64(std::string_view(data, length));
            PromiseKeeper::getInstance().resolvePromise(id, std::move(encoded));
        },
        .onError = [](void* context, const char* error) {
            uint64_t id = reinterpret_cast<uint64_t>(context);
            PromiseKeeper::getInstance().rejectPromise(id, std::string(error));
        },
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string argsStr = args.utf8(rt);
    char* mutableArgs = const_cast<char*>(argsStr.c_str());

    ::start(mutableArgs, callback);

    return *promise;
}



facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletBalance(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletBalance(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::channelBalance(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::channelBalance(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::getTransactions(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getTransactions(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::estimateFee(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::estimateFee(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::sendCoins(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendCoins(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::listUnspent(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listUnspent(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::subscribeTransactions(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeTransactions(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::sendMany(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendMany(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::newAddress(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::newAddress(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::verifyMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::verifyMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::connectPeer(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::connectPeer(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::disconnectPeer(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::disconnectPeer(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::listPeers(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listPeers(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::subscribePeerEvents(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribePeerEvents(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::getInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::getRecoveryInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getRecoveryInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::pendingChannels(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::pendingChannels(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::listChannels(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listChannels(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::subscribeChannelEvents(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeChannelEvents(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::closedChannels(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::closedChannels(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::openChannelSync(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::openChannelSync(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::openChannel(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::openChannel(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::batchOpenChannel(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::batchOpenChannel(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::fundingStateStep(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::fundingStateStep(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


jsi::Object NativeSampleModuleCxx::channelAcceptor(jsi::Runtime &rt, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::channelAcceptor(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start channelAcceptor");
    }
}


facebook::jsi::Function NativeSampleModuleCxx::closeChannel(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::closeChannel(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::abandonChannel(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::abandonChannel(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


jsi::Object NativeSampleModuleCxx::sendPayment(jsi::Runtime &rt, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::sendPayment(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start sendPayment");
    }
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::sendPaymentSync(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendPaymentSync(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


jsi::Object NativeSampleModuleCxx::sendToRoute(jsi::Runtime &rt, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::sendToRoute(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start sendToRoute");
    }
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::sendToRouteSync(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendToRouteSync(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::addInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::addInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::listInvoices(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listInvoices(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::lookupInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::lookupInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::subscribeInvoices(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeInvoices(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::decodePayReq(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::decodePayReq(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::listPayments(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listPayments(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::deletePayment(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::deletePayment(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::deleteAllPayments(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::deleteAllPayments(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::describeGraph(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::describeGraph(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::getNodeMetrics(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getNodeMetrics(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::getChanInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getChanInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::getNodeInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getNodeInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::queryRoutes(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::queryRoutes(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::getNetworkInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getNetworkInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::stopDaemon(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::stopDaemon(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::subscribeChannelGraph(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeChannelGraph(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::debugLevel(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::debugLevel(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::feeReport(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::feeReport(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::updateChannelPolicy(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::updateChannelPolicy(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::forwardingHistory(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::forwardingHistory(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::exportChannelBackup(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::exportChannelBackup(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::exportAllChannelBackups(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::exportAllChannelBackups(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::verifyChanBackup(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::verifyChanBackup(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::restoreChannelBackups(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::restoreChannelBackups(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::subscribeChannelBackups(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeChannelBackups(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::bakeMacaroon(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::bakeMacaroon(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::listMacaroonIDs(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listMacaroonIDs(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::deleteMacaroonID(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::deleteMacaroonID(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::listPermissions(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listPermissions(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::checkMacaroonPermissions(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::checkMacaroonPermissions(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


jsi::Object NativeSampleModuleCxx::registerRPCMiddleware(jsi::Runtime &rt, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::registerRPCMiddleware(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start registerRPCMiddleware");
    }
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::sendCustomMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendCustomMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::subscribeCustomMessages(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeCustomMessages(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::listAliases(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listAliases(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::lookupHtlcResolution(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::lookupHtlcResolution(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::genSeed(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::genSeed(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::initWallet(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::initWallet(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::unlockWallet(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::unlockWallet(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::changePassword(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::changePassword(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::subscribeState(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeState(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::getState(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getState(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::autopilotStatus(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::autopilotStatus(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::autopilotModifyStatus(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::autopilotModifyStatus(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::autopilotQueryScores(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::autopilotQueryScores(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::autopilotSetScores(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::autopilotSetScores(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::chainNotifierRegisterConfirmationsNtfn(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::chainNotifierRegisterConfirmationsNtfn(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function NativeSampleModuleCxx::chainNotifierRegisterSpendNtfn(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::chainNotifierRegisterSpendNtfn(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function NativeSampleModuleCxx::chainNotifierRegisterBlockEpochNtfn(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::chainNotifierRegisterBlockEpochNtfn(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function NativeSampleModuleCxx::invoicesSubscribeSingleInvoice(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesSubscribeSingleInvoice(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::invoicesCancelInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesCancelInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::invoicesAddHoldInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesAddHoldInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::invoicesSettleInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesSettleInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::invoicesLookupInvoiceV2(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesLookupInvoiceV2(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::neutrinoKitStatus(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitStatus(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::neutrinoKitAddPeer(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitAddPeer(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::neutrinoKitDisconnectPeer(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitDisconnectPeer(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::neutrinoKitIsBanned(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitIsBanned(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::neutrinoKitGetBlockHeader(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitGetBlockHeader(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::neutrinoKitGetBlock(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitGetBlock(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::neutrinoKitGetCFilter(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitGetCFilter(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::neutrinoKitGetBlockHash(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitGetBlockHash(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::peersUpdateNodeAnnouncement(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::peersUpdateNodeAnnouncement(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::routerSendPaymentV2(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSendPaymentV2(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function NativeSampleModuleCxx::routerTrackPaymentV2(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerTrackPaymentV2(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function NativeSampleModuleCxx::routerTrackPayments(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerTrackPayments(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerEstimateRouteFee(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerEstimateRouteFee(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerSendToRoute(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSendToRoute(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerSendToRouteV2(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSendToRouteV2(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerResetMissionControl(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerResetMissionControl(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerQueryMissionControl(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerQueryMissionControl(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerXImportMissionControl(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerXImportMissionControl(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerGetMissionControlConfig(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerGetMissionControlConfig(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerSetMissionControlConfig(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSetMissionControlConfig(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerQueryProbability(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerQueryProbability(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerBuildRoute(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerBuildRoute(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function NativeSampleModuleCxx::routerSubscribeHtlcEvents(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSubscribeHtlcEvents(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function NativeSampleModuleCxx::routerSendPayment(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSendPayment(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function NativeSampleModuleCxx::routerTrackPayment(jsi::Runtime &rt, jsi::String data, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerTrackPayment(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


jsi::Object NativeSampleModuleCxx::routerHtlcInterceptor(jsi::Runtime &rt, AsyncCallback2<std::string> onResponse, AsyncCallback2<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback2<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback2<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::routerHtlcInterceptor(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start routerHtlcInterceptor");
    }
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::routerUpdateChanStatus(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerUpdateChanStatus(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerSignOutputRaw(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerSignOutputRaw(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerComputeInputScript(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerComputeInputScript(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerSignMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerSignMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerVerifyMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerVerifyMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerDeriveSharedKey(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerDeriveSharedKey(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerMuSig2CombineKeys(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2CombineKeys(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerMuSig2CreateSession(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2CreateSession(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerMuSig2RegisterNonces(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2RegisterNonces(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerMuSig2Sign(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2Sign(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerMuSig2CombineSig(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2CombineSig(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::signerMuSig2Cleanup(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2Cleanup(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::versionerGetVersion(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::versionerGetVersion(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitListUnspent(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListUnspent(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitLeaseOutput(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitLeaseOutput(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitReleaseOutput(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitReleaseOutput(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitListLeases(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListLeases(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitDeriveNextKey(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitDeriveNextKey(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitDeriveKey(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitDeriveKey(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitNextAddr(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitNextAddr(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitListAccounts(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListAccounts(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitRequiredReserve(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitRequiredReserve(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitListAddresses(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListAddresses(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitSignMessageWithAddr(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitSignMessageWithAddr(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitVerifyMessageWithAddr(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitVerifyMessageWithAddr(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitImportAccount(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitImportAccount(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitImportPublicKey(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitImportPublicKey(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitImportTapscript(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitImportTapscript(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitPublishTransaction(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitPublishTransaction(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitSendOutputs(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitSendOutputs(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitEstimateFee(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitEstimateFee(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitPendingSweeps(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitPendingSweeps(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitBumpFee(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitBumpFee(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitListSweeps(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListSweeps(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitLabelTransaction(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitLabelTransaction(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitFundPsbt(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitFundPsbt(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitSignPsbt(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitSignPsbt(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::walletKitFinalizePsbt(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitFinalizePsbt(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::watchtowerGetInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerGetInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::watchtowerClientAddTower(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientAddTower(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::watchtowerClientRemoveTower(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientRemoveTower(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::watchtowerClientListTowers(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientListTowers(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::watchtowerClientGetTowerInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientGetTowerInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::watchtowerClientStats(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientStats(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise2<std::string> NativeSampleModuleCxx::watchtowerClientPolicy(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise2<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientPolicy(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


} // namespace facebook::react
